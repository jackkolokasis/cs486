\section*{Exercise B}
\paragraph{1.}
If we delete the line \textbf{pred.next = curr} then we will have the
following scenarios where the thread is going through nodes that have
been removed and thus, pred can point to a node already removed. 

\textbf{Example:}
If we have a list with 3 elements: 10, 40, and 50. The tread A try to
delete the node in 40 while the thread B try to insert the node 45
between node 40 and 50. While the thread B tries to insert the new
node does not see the new \textbf{pred.next = curr} as a result to
connect the new node with the already deleted node 40.

\paragraph{2}
In the case of the Lazy algorithm, canceling the flag marked
invalidates the validate() and contains() method that depend on this
mark.

\paragraph{3}
No, we cannot modify the insert() method of the fine-grained
synchronization list so that it locks only on node because we need to
lock the previous node and the current node each time. During the
insertion path the previous node will point to the new node and the
new node will point to the current node. In the possibility of keeping
only one lock in the current node then two threads might try to add a
new node to the previous node which that is not correct. 
