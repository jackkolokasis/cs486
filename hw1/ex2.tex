\section*{Exercise B}
\paragraph{1.}
If we delete the line \textbf{pred.next = curr} then we will have the
following scenarios where the thread is going through nodes that have
been removed and thus, pred can point to a node already removed. 

\textbf{Example:}
If we have a list with 3 elements: 10, 40, and 50. The tread A try to
delete the node in 40 while the thread B try to insert the node 45
between node 40 and 50. While the thread B tries to insert the new
node does not see the new \textbf{pred.next = curr} as a result to
connect the new node with the already deleted node 40.

\paragraph{2}
In the case of the Lazy algorithm, if we mark a node as removed by
setting its next field to null then this invalidates the validate()
method that depends on this mark.

\textbf{Example:}
If we have a list with 3 elements: 10, 40, and 50. The thread A tries
to delete the node 40 while thread B tries to access node 50. When the
tread A is going to set the next pointer to null then the node 50 is
going to be unreachable. So, thread B will not find node 50 and this
is wrong.

\paragraph{3}
No, we cannot modify the insert() method of the fine-grained
synchronization list so that it locks only on node because we need to
lock the previous node and the current node each time. During the
insertion path the previous node will point to the new node and the
new node will point to the current node. In the possibility of keeping
only one lock in the current node then two threads might try to add a
new node to the previous node which that is not correct. 
