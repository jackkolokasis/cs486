\section*{Exercise C}

\begin{lstlisting}[style=mycode]

// Node structure
struct Node {
	int _key;               // Node key
	struct Node *left;      // Left child
	struct Node *right;     // Right child
	struct Node *l_thread;  // Left threaded
	struct Node *r_thread;  // Right threaded
};

// Insert a Node in Binary Threaded Tree 
struct Node *BSTInsert(struct Node *root, int ikey) 
{ 
    Node *ptr; 
    Node *par = NULL;		// Parent node
	Node *child = NULL;	// Child node

    // Searching for a Node with given value 
	lock(root);
	ptr = root

    while (ptr != NULL) 
    { 
        // If key already exists, return 
        if (ikey == (ptr->info)) 
        { 
			unlock(root);
            return ptr; 
        } 
  
        par = ptr;	// Update parent pointer 
  
        // Moving on left subtree. 
        if (ikey < ptr->info) 
        { 
            if (ptr->l_thread == false) 
				child = ptr->left
				lock(child)
                ptr = child
            else
                break; 
        } 
  
        // Moving on right subtree. 
        else
        { 
            if (ptr->r_thread == false) 
				child = ptr->right;
				lock(child);
                ptr = child;
            else
                break; 
        } 

		unlock(par);
    } 
  
    // Create a new node 
    Node *tmp = new Node; 
    tmp->info = ikey; 
    tmp->l_thread = true; 
    tmp->r_thread = true; 
  
    if (par == NULL) 
    { 
        root = tmp; 
        tmp->left = NULL; 
        tmp->right = NULL; 
		unlock (par);
		return root;
    } 
    else if (ikey < (par->info)) 
    { 
        tmp->left = par->left; 
        tmp->right = par; 
        par->l_thread = false; 
        par->left = tmp; 
    } 
    else
    { 
        tmp->left = par; 
        tmp->right = par->right; 
        par->r_thread = false; 
        par->right = tmp; 
    } 

	unlock(par)
	unlock(root)
  
    return root; 
} 

// Insert a Node in Binary Threaded Tree 
struct Node *BSTSearch(struct Node *root, int ikey) 
{ 
    Node *ptr; 
    Node *par; 
    Node *child; 

    // Searching for a Node with given value 
	lock(root);
	ptr = root

    while (ptr != NULL) 
    { 
        // If key already exists, return 
        if (ikey == (ptr->info)) 
        { 
			unlock(ptr);
            return ptr; 
        } 

		par = ptr
  
        // Moving on left subtree. 
        if (ikey < ptr->info) 
        { 
            if (ptr->l_thread == false) 
				child = ptr->left
				lock(child)
                ptr = child
            else
                break; 
        } 
  
        // Moving on right subtree. 
        else
        { 
            if (ptr->r_thread == false) 
				child = ptr->right;
				lock(child);
                ptr = child;
            else
                break; 
        } 

		unlock(par);
    } 
} 

// Insert a Node in Binary Threaded Tree 
struct Node *BSTSearch(struct Node *root, int ikey) 
{ 
    Node *ptr; 
    Node *par; 
    Node *child; 

    // Searching for a Node with given value 
	lock(root);
	ptr = root

    while (ptr != NULL) 
    { 
        // If key already exists, return 
        if (ikey == (ptr->info)) 
        { 
			unlock(ptr);
            return ptr; 
        } 

		par = ptr
  
        // Moving on left subtree. 
        if (ikey < ptr->info) 
        { 
            if (ptr->l_thread == false) 
				child = ptr->left
				lock(child)
                ptr = child
            else
                break; 
        } 
  
        // Moving on right subtree. 
        else
        { 
            if (ptr->r_thread == false) 
				child = ptr->right;
				lock(child);
                ptr = child;
            else
                break; 
        } 

		unlock(par);
    } 
} 

// Delete a Node in Binary Threaded Tree 
struct Node *BSTDelete(struct Node *root, int ikey) 
{ 
    Node *ptr; // Current pointer
    Node *par; // Parent pointer
    Node *child; // Child pointer
	int found = 0;	// Key is found 

    // Searching for a Node with given value 
	lock(root);
	ptr = root

	// Search the key
    while (ptr != NULL) 
    { 
		if (dkey == ptr->info)
		{
			found = 1
			break;
		}

		par = ptr

		if (dkey < ptr->info)
		{
			if (ptr->lthread == false)
			{
				child = ptr->left;
				lock(child);
			}
			else
				break;
		}
		else {
			if (ptr->rthread == false)
			{
				child = ptr->right;
				lock(child);
			}
			else
				break;
		}

		unlock(par);
	} 

	if (found == 0)
		printf("The key does not found");

	else if (ptr->lthread == false && ptr->rthread == false)
	{
		struct Node* par_succ = ptr;
		struct Node* succ = ptr->right;

		lock(succ);

		while (succ->left != NULL)
		{
			parsucc = succ;
			succ = succ->left;
			lock(suck)
		}

		ptr->key = succ->key
	}

\end{lstlisting}

\paragraph{2.}
We implement a fine-grain locking for the lock-based implementation of
the concurrent threaded binary search tree. In our implementation we
lock the parent node, the current node and the child node of each
visit node.

\paragraph{3.}
Let us have the scenario that I have a null tree, then add a new key
and then I delete this key. As a result we will have a null tree
again.
Liniarization points in Insertion: line 69 or line 88 where the new
element is already inserted in the tree.
Liniarization points in Deletion: line xx or line xx.


\paragraph{4.}
The algorithm is correct because for each node that we traverse we
lock the parent node and the child node. By keeping these three nodes
locked during insertion and deletion operation we ensure that we are
going to perform correctly each one operation.

\paragraph{5.}


\paragraph{6.}

