\section*{Exercise C}

\begin{lstlisting}

struct Node {
	int _key;
	int _is_locked;
	int _is_leaf;
	struct Node *_l_child;
	struct Node *_l_child;
	struct Node *_l_threaded;
	struct Node *_r_threaded;
}

struct Lock_Array {
	struct Node* data;
}

stuct Node* get_next_node(stuct Node* tmp, int key)
{
	
}

\end{lstlisting}
%
%
%
%
%struct Node {
%	l, r,
%	is_locked
%	l_trhead
%	r_thread
%	is_leaf
%}
%
%struct lock_array {
%	struct Node *tmp;
%}
%
%struct Node get_next(struct Node *tmp, int key)
%{
%
%
%	return tmp;
%}
%
%lock_array[height];
%i = 0;
%
%lock(root)
%lock_array[i++] = root.is_locked
%tmp_ptr = root
%tmp_child;
%
%while (tmp_ptr.is_leaf != 1 )
%{
%	tmp_child = get_next(tmp_ptr, key);
%
%	lock(tmp_child);
%	lock_array[i++] = tmp_child.is_locked;
%
%	tmp_ptr = child;
%	unlock(lock_array[i-2]);
%}
%
%Node tmp = new Node;
%
%if (i = 1) // root leaf
%{
%
%	tmp_ptr.l = tmp
%}
%else
%{
%	tmp_child.l or r = tmp;
%}
%
%unlock(lock_array[i-1])
%

\paragraph{2.}
We implement a new 
